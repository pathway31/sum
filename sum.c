#include <time.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

/*
    Check the program's asm to verify that sum_array() and sum_linked_list()
    haven't been optimized away, and that both are called inside sum() (neither are not 
    inlined away)

    All of the following asm is from the binary generated by gcc version 13.3.0, with the command:
        gcc sum.c -Wall -O3 -o sum

    <sum_array>:
        12e4:	mov    QWORD PTR [rsp-0x8],0x0 # sum = 0
        12ed:   test   rsi,rsi                 # if the array's len is zero,
        12f0:	je     1317                    # then return
        12f2:	lea    rdx,[rdi+rsi*8]         # rdx = the address one past the last element of the array, &array[len]
        1300:	mov    rax,QWORD PTR [rsp-0x8] # rax = sum
        1305:	add    rdi,0x8                 # rdi += sizeof(uint64_t)
        1309:	add    rax,QWORD PTR [rdi-0x8] # rax += array[i-1].data
        130d:	mov    QWORD PTR [rsp-0x8],rax # sum = rax
        1312:	cmp    rdx,rdi                 # if &array[i] <= the address one past the
        1315:	jne    1300                    # last element of the array, then keep looping
        1317:	ret

    <sum_linked_list>:
        1474:	mov    QWORD PTR [rsp-0x8],0x0 # sum = 0
        147d:	test   rdi,rdi                 # if the head of the linked list is null,
        1480:	je     149e                    # then return
        1488:	mov    rax,QWORD PTR [rsp-0x8] # rax = sum
        148d:	add    rax,QWORD PTR [rdi]     # rax += curr.data
        1490:	mov    rdi,QWORD PTR [rdi+0x8] # curr = curr.next
        1494:	mov    QWORD PTR [rsp-0x8],rax # sum = rax 
        1499:	test   rdi,rdi                 # if curr != NULL,
        149c:	jne    1488                    # then keep looping
        149e:	ret

    <sum>:
        ...
        14f2:   mov    r13,rax
        14f5:	call   1470 <sum_linked_list>
        14fa:	call   10e0 <clock@plt>
        ...
        1531:	mov    r13,rax
        1534:	call   12e0 <sum_array>
        1539:	call   10e0 <clock@plt>
        ...
*/

const size_t LEN_ARGPOS = 1;
const size_t NUM_ARGS = 1+1; // +1 because the 0th arg is the program invocation

struct Node {
    uint64_t data;
    struct Node* next;
};

struct SumTimes {
    double ll_time;
    double arr_time; 
};

uint64_t* __attribute__((noinline)) create_array(
    const size_t len, 
    const uint64_t* const ints
) {
    uint64_t* array = malloc( len * sizeof(uint64_t) );
    for (size_t i = 0; i < len; i++) {
        array[i] = ints[i];
    }
    return array;
}

void __attribute__((noinline)) delete_array(uint64_t* array) {
    free(array);
}

void __attribute__((noinline)) sum_array(
    const uint64_t* const array,
    const size_t len
) {
    // sum should have an unsigned type because overflowing an unsigned integer isn't UB,
    // unlike a signed integer
    volatile uint64_t sum = 0;
    for (size_t i = 0; i < len; i++) {
	    sum += array[i];
    }
}

struct Node* __attribute__((noinline)) create_linked_list(
    const size_t len,
    const uint64_t* const ints
) {
    if (len == 0) {
	    return NULL;
    }

    struct Node** nodes = malloc( len * sizeof(struct Node*) );
    for (size_t i = 0; i < len; i++) {
	struct Node* node = (struct Node*) malloc(sizeof(struct Node));
        node->data = 0;
        node->next = NULL;
    	nodes[i] = node;
    }

    /*
    	Shuffle the nodes around in memory. Doing this artificially 
        imitates a linked list whose nodes are scattered across the 
	    heap.
      
        For small structs like Node, glibc's malloc() implementation
        will return addresses that are evenly-spaced and monotonically
        increasing, like this:
    
	        0x...6f0
	        0x...710
	        0x...730
     
            * The 16 bytes of space between nodes is the metadata stored 
              by glibc's allocator (16 bytes of node, then 16 bytes of
              metadata, then 16 bytes of node, etc.)

        This isn't desirable because this program is trying to benchmark
        iteration over linked  lists whose nodes have been added and removed 
        over an extended period of time. In that case, many other calls to 
        malloc() and free() are made inbetween nodes being allocated, so each 
        new node gets allocated at some random-ish place on the heap rather than
        immediately after the previously-allocated node.
    */ 
    for (size_t i = 0; i < len*2; i++) {
	    size_t idx1 = rand() % len;
	    size_t idx2 = rand() % len;
	    struct Node* tmp = nodes[idx1];
	    nodes[idx1] = nodes[idx2];
	    nodes[idx2] = tmp;
    }
    
    for (size_t i = 0; i < len-1; i++) {
        nodes[i]->next = nodes[i+1];
        nodes[i]->data = ints[i];
    }
    nodes[len-1]->next = NULL;
    nodes[len-1]->data = ints[len-1];
    struct Node* head = nodes[0];
    free(nodes);
    
    return head;
}

void __attribute__((noinline)) delete_linked_list(struct Node* head) {
    struct Node* curr = head;
    while (curr) {
        struct Node* next = curr->next;
        free(curr);
        curr = next;
    }
}

void __attribute__((noinline)) sum_linked_list(struct Node* const head) {
    volatile uint64_t sum = 0;
    struct Node* curr = head;
    while (curr != 0) {
    	sum += curr->data;
        curr = curr->next;
    }
}

struct SumTimes sum(const size_t len) {
    // Each data structure is summed immediately after it's created.
    // This should mean that L1d and up are saturated with its latter 
    // elements, from some element near the last element up to and 
    // including the last element. If all elements fit into L1d, then 
    // then the only cache-related thing being measured is L1d 
    // access speed.
    
    uint64_t* ints = malloc( len * sizeof(uint64_t) );
    for (size_t i = 0; i < len; i++) {
        ints[i] = rand();
    }

    struct Node* head = create_linked_list(len, ints);    
    clock_t start_ll = clock();
    sum_linked_list(head);
    clock_t end_ll = clock();
    double ll_time = (double) (end_ll-start_ll) / (double) CLOCKS_PER_SEC;
    delete_linked_list(head);

    uint64_t* array = create_array(len, ints);
    clock_t start_arr = clock();
    sum_array(array, len);
    clock_t end_arr = clock();
    double arr_time = (double) (end_arr-start_arr) / (double) CLOCKS_PER_SEC;
    delete_array(array);

    free(ints);

    struct SumTimes times;
    times.ll_time = ll_time;
    times.arr_time = arr_time; 
    return times;
}

int main(int argc, char **argv) {
    if (argc < NUM_ARGS) {
        printf("Error: missing a len argument\n");
        return 0;
    }

    size_t len = (size_t) strtol(argv[LEN_ARGPOS], NULL, 10);
    struct SumTimes times = sum(len);
    printf("%ld %f %f\n", len, times.arr_time, times.ll_time);
    return 0;
}